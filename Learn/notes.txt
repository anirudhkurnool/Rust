cargo build => to build a executable
cargo run => build an executable and then run it
cargo check => check for errors without building a executable

in rust variable are declared using the "let" keyword 

in rust by default the variables are immutable

rust has automatic type inference

io::stdin().read_line(&mut string_var)

Result{ok, err}

handle this using expect function which prints out user given text when the Result is error

Ordering is a enum which is the result of comparison of two numbers -1=>less 1=>greater 0=>equal

const variables must be type annotated

value of a const should be known at run time i.e you can't assign the return value of a function to const variables 

Rust has 4 main scalar data type 
(1)Integers - signed    - i8, i16, i32, i64, i128, isize, iarch(architecture dependent)
            - unsigned  - u8, u16, u32, u64, u128, usize, uarch(architecture dependent)
(2)Floats - f8, f16, f32, f64
(3)Booleans - bool 
(4)Charaters - char (Unicode character)

Integer overflow 
(1)In debug mode rust panics 
(2)In release modes rust performs 2's complement wrapping

2's complement wrapping ??? 

default integer is i32 
default float is  f64

Rust has 2 compound types 
(1)Tuple (can contain heteregenous data)
(2)Arrays (can contian only homogeneous data)

Rust arrays have bound checking 

rust uses snake_case for function names

In rust a line of code is either a statement(ends with ;) or expression

All expressions return something in rust

In rust for control flow the conditions should be explicitly boolean 
if number {
    println!("throws a error ")
}

========== Ownership ==========
this concept of rust gives memory safety guarentees without the use of the garbage collector

Memory -> Two Types -> 1)Stack(fixed and cannot increase during run time) 2)Heap (can increase during run time)

size of varibles that are to be stored in stack should be known at compile time.

rust function activation is same as C functions activation record

strings in rust by default stored on the heap ?(string literals vs String)

accessing variable on stack in faster than accessing variables on the heap ??? 

allocating memory on the stack is much faster than allocating memory on the heap(a algo has to look for the best possible block of memory that is large enough for the data we want to store) (best fit / worst fit/) ??

Ownership Rules In Rust
(1)Each value has a owner variable in rust.
(2)A value can be owned by only one owner at a time.
(3)Whenever the owner goes out of the scope the value is deleted.


Shallow Copy vs Deep Copy ???
Pass by value vs Pass by reference ??? 

Rules for reference 
(1)At any point in time there can be any number of immutable references or a single mutable reference 
(2)Reference must always be valid

Slices borrow only certain amount of value of the complex type rather than the whole
